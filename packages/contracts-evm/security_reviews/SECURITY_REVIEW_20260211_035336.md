# Security Review: contracts-evm Package

**Date:** 2026-02-11 (UTC)  
**Reviewer:** Automated Security Review  
**Package:** `packages/contracts-evm`

---

## Executive Summary

This document provides a full security review of the contracts-evm package, covering test coverage, common Solidity vulnerabilities, flows, and access control (RBAC). The bridge implements a cross-chain asset transfer system with user-initiated withdrawals, operator approvals, and a canceler role for withdrawal cancellation within a time window.

### Key Findings Summary

| Severity | Count | Summary |
|----------|-------|---------|
| High | 1 | RBAC deviation: operators have broader privileges than spec |
| Medium | 3 | Missing validation, test gaps, potential configuration issues |
| Low/Info | 5 | Recommendations for hardening |

---

## 1. Test Coverage

### 1.1 Coverage Overview

- **Total test suites:** 16 (Bridge, ChainRegistry, TokenRegistry, LockUnlock, MintBurn, GuardBridge, BlacklistBasic, TokenRateLimit, HashLib, FeeCalculatorLib, AddressCodecLib, AccessManagerEnumerable, DatastoreSetAddress, FactoryTokenCl8yBridged, TokenCl8yBridged)
- **Total tests:** ~356 passing
- **Forge coverage:** Coverage run fails with "Stack too deep" when optimizer is disabled; use `--ir-minimum` for coverage. Historical CODE_REVIEW.md reports ~98% line coverage.

### 1.2 Per-Contract Test Status

| Contract | Tests | Status |
|----------|-------|--------|
| Bridge | 35 | ✅ Good |
| ChainRegistry | 21 | ✅ Good |
| TokenRegistry | 14 | ✅ Good |
| LockUnlock | 8 | ✅ Adequate |
| MintBurn | 7 | ✅ Adequate |
| GuardBridge | 9 | ✅ Good |
| BlacklistBasic | 7 | ✅ Adequate |
| TokenRateLimit | 11 | ✅ Good |
| HashLib | 38 | ✅ Excellent |
| FeeCalculatorLib | 32 | ✅ Good |
| Others | Various | ✅ Adequate |

### 1.3 Test Coverage Gaps

1. **`depositNative`** – Not covered in `Bridge.t.sol`. Native ETH deposits are a critical path; tests should verify:
   - Successful deposit with fee deduction
   - Revert when `wrappedNative` is not set (see Medium #1)
   - Revert when chain/token invalid
   - Fee transfer to recipient

2. **`withdrawExecuteMint`** – `Bridge.t.sol` has `test_WithdrawExecuteUnlock` but no equivalent for mint-mode tokens. Add `test_WithdrawExecuteMint` covering the full flow for MintBurn tokens.

3. **`depositNative` when `wrappedNative == address(0)`** – Current code does not revert; behavior is undefined and could lead to invalid cross-chain state.

4. **Guard modules integration with Bridge** – `GuardBridge` is tested in isolation. Integration tests with the main `Bridge` flow (if the Bridge uses guards) would strengthen coverage.

---

## 2. Top Common Solidity Issues

### 2.1 Reentrancy ✅

- **Bridge:** Uses `ReentrancyGuard` and `nonReentrant` on all deposit/withdraw entry points.
- **LockUnlock / MintBurn:** Use `ReentrancyGuard` on `lock`, `unlock`, `burn`, `mint`.
- **ETH transfer in `depositNative`:** Fee is sent via `feeConfig.feeRecipient.call{value: fee}("")` after state updates; `nonReentrant` prevents reentrancy.
- **`withdrawApprove`:** Sends `operatorGas` to `msg.sender` after setting `w.approved = true`. `nonReentrant` prevents reentrancy. State is updated before external call, which is correct.

**Verdict:** Reentrancy protections are in place.

### 2.2 Integer Overflow / Underflow ✅

- Solidity `^0.8.30` has built-in overflow/underflow checks.
- No use of `unchecked` in critical paths that would bypass safety.

**Verdict:** No issues identified.

### 2.3 Access Control ⚠️

See Section 4 for detailed RBAC analysis. Operators currently have more privileges than the specified design (e.g., fee params, chain/token registration).

### 2.4 Unchecked Low-Level Calls

- **`depositNative`:** `(bool success,) = feeConfig.feeRecipient.call{value: fee}(""); require(success, "Fee transfer failed");` – Properly checked.
- **`withdrawApprove`:** `(bool success,) = msg.sender.call{value: w.operatorGas}(""); require(success, "Operator gas transfer failed");` – Properly checked.

**Verdict:** External value transfers are guarded.

### 2.5 Front-Running

- **`withdrawSubmit`:** Anyone can submit a withdrawal for any `(srcChain, srcAccount, destAccount, token, amount, nonce)`. Recipient is derived from `destAccount`.
- **`withdrawExecuteUnlock` / `withdrawExecuteMint`:** Anyone can execute an approved withdrawal. Funds go to `w.recipient`, so this is by design (permissionless execution after approval).

**Verdict:** By design; no vulnerability from front-running in the execute step.

### 2.6 Centralization Risks

- **UUPS upgrades:** `_authorizeUpgrade` is `onlyOwner`; owner can upgrade implementations.
- **Pause:** Owner can pause deposits/withdrawals.
- **Registries:** Owner and operators (depending on RBAC) control chain and token registration.

**Verdict:** Expected for this architecture; document clearly in operations runbooks.

### 2.7 Token Assumptions

- **LockUnlock / MintBurn:** Balance checks before/after transfers guard against rebasing or fee-on-transfer tokens. Documentation states rebasing and balance-modifying tokens are not supported.
- **Fee-on-transfer:** In `depositERC20`, fee is transferred first, then `lockUnlock.lock(msg.sender, token, netAmount)` – if the token takes a fee on transfer, `netAmount` could be incorrect. Consider documenting that fee-on-transfer tokens are unsupported.

**Verdict:** Documented as unsupported; consider explicit revert or documentation for non-standard tokens.

---

## 3. Flows

### 3.1 Deposit Flow

1. **depositERC20 / depositERC20Mintable**
   - User approves Bridge (for fee) and LockUnlock/MintBurn (for net amount).
   - Bridge checks: `whenNotPaused`, `nonReentrant`, amount > 0, token registered, dest chain registered.
   - Fee calculated and sent to `feeRecipient`.
   - Net amount locked (LockUnlock) or burned (MintBurn).
   - Deposit record stored with `depositNonce++`.
   - `Deposit` event emitted.

2. **depositNative**
   - User sends ETH via `depositNative{value: X}`.
   - Bridge checks: `whenNotPaused`, `nonReentrant`, `msg.value > 0`, dest chain registered.
   - **Missing check:** `wrappedNative != address(0)`.
   - Fee sent to `feeRecipient`; net amount remains in Bridge.
   - Deposit record uses `token: wrappedNative`; if unset, destination mapping is undefined.

### 3.2 Withdraw Flow

1. **withdrawSubmit** (public)
   - Anyone can submit `(srcChain, srcAccount, destAccount, token, amount, nonce)`.
   - Recipient = `HashLib.bytes32ToAddress(destAccount)`.
   - `PendingWithdraw` created with `submittedAt`, `approved: false`, `operatorGas`.

2. **withdrawApprove** (operator only)
   - Operator sets `approved = true`, `approvedAt = block.timestamp`.
   - Operator receives `operatorGas` if > 0.

3. **withdrawCancel** (canceler only)
   - Within `cancelWindow` after `approvedAt`, canceler can set `cancelled = true`.
   - Only if `approved` is true.

4. **withdrawUncancel** (operator only)
   - Operator can uncancel and reset `approvedAt` to restart the cancel window.

5. **withdrawExecuteUnlock / withdrawExecuteMint** (public)
   - Anyone can execute if: `approved`, not `cancelled`, `block.timestamp >= approvedAt + cancelWindow`.
   - Unlock or mint to `recipient`.

### 3.3 Hash Consistency

- `HashLib.computeXchainHashId(srcChain, destChain, srcAccount, destAccount, token, amount, nonce)` is used on both deposit (source) and withdraw (destination).
- Deposit: `srcChain = thisChainId`, `destChain = destChain`, `destChain = thisChainId` on dest side.
- Correct alignment ensures cross-chain matching.

---

## 4. Access Control (RBAC)

### 4.1 Expected RBAC (per requirements)

| Role | ID | Responsibilities |
|------|-----|-----------------|
| Admin | 0 | System variables (pause, cancelWindow, wrappedNative), operator/canceler management, chain/token registration, upgrades |
| Operator | 1 | **Only** `withdrawApprove` |
| Canceler | 2 | **Only** `withdrawCancel` |
| Public | - | `deposit*`, `withdrawSubmit`, `withdrawExecute*` |

### 4.2 Current Implementation

#### Bridge

| Function | Expected | Actual |
|----------|----------|--------|
| `pause`, `unpause` | Admin | ✅ `onlyOwner` |
| `setWrappedNative`, `setCancelWindow` | Admin | ✅ `onlyOwner` |
| `addOperator`, `removeOperator` | Admin | ✅ `onlyOwner` |
| `addCanceler`, `removeCanceler` | Admin | ✅ `onlyOwner` |
| `setFeeParams` | Admin | ❌ `onlyOperator` |
| `setCustomAccountFee`, `removeCustomAccountFee` | Admin | ❌ `onlyOperator` |
| `withdrawApprove`, `withdrawUncancel` | Operator | ✅ `onlyOperator` |
| `withdrawCancel` | Canceler | ✅ `onlyCanceler` |
| `deposit*`, `withdrawSubmit`, `withdrawExecute*` | Public | ✅ No role required |
| `upgradeToAndCall` | Admin | ✅ `onlyOwner` |

#### ChainRegistry

| Function | Expected | Actual |
|----------|----------|--------|
| `registerChain`, `unregisterChain` | Admin | ❌ `onlyOperator` (operators + owner) |
| `addOperator`, `removeOperator` | Admin | ✅ `onlyOwner` |

#### TokenRegistry

| Function | Expected | Actual |
|----------|----------|--------|
| `registerToken`, `setTokenDestination`, `setTokenType` | Admin | ❌ `onlyOperator` |
| `addOperator`, `removeOperator` | Admin | ✅ `onlyOwner` |

### 4.3 RBAC Deviation (High)

**Issue:** Operators can perform admin-level actions:

1. **Bridge:** `setFeeParams`, `setCustomAccountFee`, `removeCustomAccountFee` – fee and system config.
2. **ChainRegistry:** `registerChain`, `unregisterChain` – chain configuration.
3. **TokenRegistry:** `registerToken`, `setTokenDestination`, `setTokenDestinationWithDecimals`, `setTokenType` – token configuration.

**Recommendation:** Restrict these to admin (owner) only:

- Bridge: Change `setFeeParams`, `setCustomAccountFee`, `removeCustomAccountFee` from `onlyOperator` to `onlyOwner`.
- ChainRegistry: Change `registerChain`, `unregisterChain` from `onlyOperator` to `onlyOwner`.
- TokenRegistry: Change `registerToken`, `setTokenDestination`, `setTokenDestinationWithDecimals`, `setTokenType` from `onlyOperator` to `onlyOwner`.

Alternatively, introduce a dedicated admin role separate from owner if a more granular RBAC model is desired.

### 4.4 Operator vs Owner Overlap

- `_onlyOperator` allows `operators[msg.sender] || msg.sender == owner()`.
- So the owner (admin) can also act as operator, which is acceptable.
- The problem is that plain operators should not have chain/token/fee config rights.

### 4.5 LockUnlock / MintBurn

- `addAuthorizedCaller`, `removeAuthorizedCaller`: `onlyOwner` ✅  
- `lock`, `unlock`, `burn`, `mint`: `onlyAuthorized` (Bridge must be added by owner) ✅

### 4.6 GuardBridge / BlacklistBasic / TokenRateLimit

- Use OpenZeppelin `AccessManaged` with `restricted` modifier.
- Guard module management and limit configuration are correctly restricted.

---

## 5. Additional Findings

### 5.1 depositNative when wrappedNative is Not Set (Medium)

**Location:** `Bridge.sol` lines 339–377

**Issue:** `depositNative` does not require `wrappedNative != address(0)`. If `wrappedNative` is unset:

- `getDestToken(address(0), destChain)` returns the mapping for address(0), typically `bytes32(0)`.
- The deposit is recorded and emitted, but the destination has no meaningful token mapping.
- ETH remains in the Bridge and may be unclaimable or mismatched across chains.

**Recommendation:** Add at the start of `depositNative`:

```solidity
if (wrappedNative == address(0)) revert WrappedNativeNotSet();
```

### 5.2 GuardBridge.checkDeposit/checkWithdraw State Mutations (Low)

**Location:** `TokenRateLimit.sol` – `checkDeposit` and `checkWithdraw` mutate `depositWindowPerToken` and `withdrawWindowPerToken`.

**Note:** If the Bridge calls these guards, the view vs. mutable semantics of guard hooks should be clearly documented. Guard modules that change state on “check” may surprise integrators.

### 5.3 Fee Recipient Validation

**Location:** `Bridge.sol` – `setFeeParams` checks `feeRecipient != address(0)` ✅. No check for contract vs EOA; if `feeRecipient` is a contract that rejects ETH, `depositNative` fee transfer could revert.

**Recommendation:** Document that `feeRecipient` must accept plain ETH, or consider `transfer` vs `call` semantics for predictability.

### 5.4 Cancel Window Edge

**Location:** `Bridge.sol` – `_validateWithdrawExecution` uses `block.timestamp < windowEnd` to block execution. At `block.timestamp == windowEnd`, execution is allowed. Confirm this matches the intended policy (inclusive vs exclusive boundary).

---

## 6. Recommendations Summary

### Critical

1. **Enforce RBAC spec** – Restrict `setFeeParams`, `setCustomAccountFee`, `removeCustomAccountFee`, `registerChain`, `unregisterChain`, `registerToken`, `setTokenDestination`, `setTokenType` to admin (owner) only.

### High

2. **Validate `wrappedNative` in `depositNative`** – Revert when `wrappedNative == address(0)`.

### Medium

3. **Add tests for `depositNative`** – Successful path, fee handling, and revert when `wrappedNative` is not set.
4. **Add tests for `withdrawExecuteMint`** – Full flow for MintBurn tokens.
5. **Document fee-on-transfer** – Explicitly state that fee-on-transfer and rebasing tokens are unsupported.

### Low

6. **Document guard semantics** – State that some guard modules may mutate storage during checks.
7. **Clarify cancel window boundary** – Document whether `block.timestamp == windowEnd` is allowed or not.
8. **Consider invariant tests** – Add Forge invariant tests for central invariants (e.g., total locked = sum of deposits, nonce monotonicity).

---

## 7. Appendix: Contract Inventory

| Contract | Purpose |
|----------|---------|
| Bridge | Main bridge: deposits, withdrawals, approvals, cancel |
| ChainRegistry | Chain ID and identifier registry |
| TokenRegistry | Token registration and per-chain mappings |
| LockUnlock | Lock/unlock ERC20 for LockUnlock tokens |
| MintBurn | Burn/mint for MintBurn tokens |
| GuardBridge | Composable guard orchestration (account, deposit, withdraw) |
| BlacklistBasic | Account blacklist guard |
| TokenRateLimit | Per-token 24h rate limits |
| AccessManagerEnumerable | Extended AccessManager with enumeration |
| DatastoreSetAddress | Generic address set storage |
| FactoryTokenCl8yBridged | Bridged token factory |
| TokenCl8yBridged | Bridged ERC20 token implementation |
| HashLib | Transfer hash and encoding utilities |
| FeeCalculatorLib | Fee calculation (standard, discounted, custom) |
| AddressCodecLib | Address encoding/decoding for Cosmos/EVM |
| Create3Deployer | Deterministic deployment support |

---

*End of Security Review*
