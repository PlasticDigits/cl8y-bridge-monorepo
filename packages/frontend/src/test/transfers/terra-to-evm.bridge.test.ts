/**
 * Terra → EVM Bridge Integration Test
 *
 * Tests the full bridge transfer lifecycle from Terra to EVM (anvil):
 * 1. Record initial ERC20 balance on anvil
 * 2. Lock tokens on Terra via terrad
 * 3. Call withdrawSubmit on anvil via cast
 * 4. Wait for operator approval
 * 5. Skip cancel window, wait for execution
 * 6. Assert recipient balance increased
 *
 * ┌─────────────────────────────────────────────────────────────────────┐
 * │  REQUIRES FULL LOCAL INFRASTRUCTURE RUNNING BEFORE EXECUTION.      │
 * │                                                                    │
 * │  You need ALL of the following:                                    │
 * │    1. Anvil        (EVM devnet)       → localhost:8545             │
 * │    2. Anvil1       (second EVM chain) → localhost:8546             │
 * │    3. LocalTerra   (Cosmos devnet)    → localhost:1317 (LCD)       │
 * │    4. PostgreSQL   (operator DB)      → localhost:5433             │
 * │    5. Operator     (cl8y-relayer)     → localhost:9092             │
 * │    6. .env.e2e.local generated by the setup script                 │
 * │                                                                    │
 * │  Quick start:                                                      │
 * │    make test-bridge-integration                                    │
 * │                                                                    │
 * │  Or manually:                                                      │
 * │    docker compose up -d anvil anvil1 localterra postgres           │
 * │    npx vitest run --config vitest.config.integration.ts            │
 * │                                                                    │
 * │  DO NOT run via `npx vitest run` — use the integration config.     │
 * └─────────────────────────────────────────────────────────────────────┘
 */

import { describe, it, expect, beforeAll } from 'vitest'
import { execSync } from 'child_process'
import { readFileSync, existsSync } from 'fs'
import { resolve } from 'path'
import { getErc20Balance, skipAnvilTime } from '../../../e2e/fixtures/chain-helpers'
import {
  withdrawSubmitViaCast,
  withdrawExecuteViaCast,
  pollForApproval,
  computeXchainHashIdViaCast,
  ANVIL_ACCOUNTS,
} from '../../../e2e/fixtures/transfer-helpers'

const ROOT_DIR = resolve(__dirname, '../../../../..')
const ENV_FILE = resolve(ROOT_DIR, '.env.e2e.local')

// Config loaded from env file
let envVars: Record<string, string> = {}
const ANVIL_RPC = 'http://localhost:8545'
const TERRA_LCD = 'http://localhost:1317'

function loadEnv() {
  if (!existsSync(ENV_FILE)) {
    throw new Error(
      '\n' +
      '╔══════════════════════════════════════════════════════════════════╗\n' +
      '║  BRIDGE TEST ABORTED — .env.e2e.local not found                ║\n' +
      '╠══════════════════════════════════════════════════════════════════╣\n' +
      '║  This file is generated by the E2E setup script after          ║\n' +
      '║  deploying contracts to local chains.                          ║\n' +
      '║                                                                ║\n' +
      '║  Quick start:  make test-bridge-integration                    ║\n' +
      '║  Or manually:  docker compose up -d anvil anvil1 localterra    ║\n' +
      '║  Then run:     npx vitest run --config vitest.config.integration.ts ║\n' +
      '╚══════════════════════════════════════════════════════════════════╝\n'
    )
  }
  const content = readFileSync(ENV_FILE, 'utf8')
  for (const line of content.split('\n')) {
    const trimmed = line.trim()
    if (!trimmed || trimmed.startsWith('#')) continue
    const eq = trimmed.indexOf('=')
    if (eq > 0) {
      envVars[trimmed.slice(0, eq)] = trimmed.slice(eq + 1)
    }
  }
}

describe('Terra → EVM Bridge Transfer', () => {
  let bridgeAddress: string
  let terraBridgeAddress: string
  let tokenA: string

  beforeAll(() => {
    loadEnv()
    bridgeAddress = envVars['VITE_EVM_BRIDGE_ADDRESS'] || ''
    terraBridgeAddress = envVars['VITE_TERRA_BRIDGE_ADDRESS'] || ''
    tokenA = envVars['ANVIL_TOKEN_A'] || ''

    if (!bridgeAddress || !terraBridgeAddress) {
      throw new Error('Missing bridge addresses in .env.e2e.local')
    }
  })

  it('should complete a Terra → EVM transfer with operator relay', async () => {
    // Use user4 to avoid nonce conflicts with other tests running in parallel
    const recipient = ANVIL_ACCOUNTS.user4
    const recipientKey = ANVIL_ACCOUNTS.user4Key
    const amount = '1000000' // 1 LUNC (6 decimals)

    // 1. Record initial ERC20 balance on anvil
    // For Terra → EVM, the destination token depends on the bridge mapping
    // Using tokenA as the destination ERC20
    let initialBalance = 0n
    if (tokenA) {
      initialBalance = await getErc20Balance(ANVIL_RPC, tokenA, recipient)
    }
    console.log(`[test] Initial balance of ${recipient}: ${initialBalance}`)

    // 2. Deposit on Terra via terrad using V2 deposit_native message
    // dest_chain: bytes4 of V2 chain ID 1 (Anvil) as base64
    // dest_account: bytes32 left-padded recipient address as base64
    const destChainB64 = btoa(String.fromCharCode(0, 0, 0, 1)) // V2 chain ID 1 (Anvil) as bytes4 base64
    const recipientClean = recipient.slice(2).toLowerCase()
    const destAccountBytes = new Uint8Array(32)
    for (let i = 0; i < 20; i++) {
      destAccountBytes[12 + i] = parseInt(recipientClean.slice(i * 2, i * 2 + 2), 16)
    }
    const destAccountB64 = btoa(String.fromCharCode(...destAccountBytes))

    const depositMsg = JSON.stringify({
      deposit_native: {
        dest_chain: destChainB64,
        dest_account: destAccountB64,
      },
    })

    let terraTxHash: string
    try {
      const result = execSync(
        [
          'docker compose exec -T localterra',
          'terrad tx wasm execute',
          terraBridgeAddress,
          `'${depositMsg}'`,
          `--amount ${amount}uluna`,
          '--from test1',
          '--keyring-backend test',
          '--chain-id localterra',
          '--gas auto',
          '--gas-adjustment 1.5',
          '--fees 10000000uluna',
          '-y',
          '--output json',
        ].join(' '),
        { cwd: ROOT_DIR, encoding: 'utf8', timeout: 30_000 }
      )
      const txResult = JSON.parse(result)
      terraTxHash = txResult.txhash
      console.log(`[test] Terra deposit_native tx: ${terraTxHash}`)
    } catch (err) {
      console.error('[test] Terra deposit_native failed:', err)
      throw err
    }

    // Wait for Terra tx to be included in a block
    await new Promise((r) => setTimeout(r, 5000))

    // 3. Extract nonce from Terra tx (query via LCD)
    // V2 deposit_native emits events with type 'wasm' or 'wasm-deposit_native'
    let nonce = 0
    try {
      const txResult = execSync(
        `curl -s ${TERRA_LCD}/cosmos/tx/v1beta1/txs/${terraTxHash}`,
        { encoding: 'utf8', timeout: 10_000 }
      )
      const parsed = JSON.parse(txResult)
      // Look for nonce in wasm events (V2 emits 'nonce' attribute)
      for (const event of parsed.tx_response?.events || []) {
        if (event.type === 'wasm' || event.type === 'wasm-deposit_native' || event.type === 'wasm-lock') {
          for (const attr of event.attributes) {
            const key = attr.key
            if (key === 'nonce' || key === 'deposit_nonce') {
              nonce = parseInt(attr.value, 10)
            }
          }
        }
      }
      console.log(`[test] Deposit nonce: ${nonce}`)
    } catch (err) {
      console.warn('[test] Failed to extract nonce:', err)
    }

    // 4. Call withdrawSubmit on anvil
    // srcChain = Terra = 0x00000002
    // srcAccount = Terra address as bytes32 (padded)
    const srcChain = '0x00000002'
    const srcAccount = '0x' + '0'.repeat(64) // simplified - Terra address encoding
    const destAccount = '0x' + ANVIL_ACCOUNTS.user4.slice(2).padStart(64, '0')

    if (tokenA) {
      const wsTxHash = withdrawSubmitViaCast({
        rpcUrl: ANVIL_RPC,
        bridgeAddress,
        privateKey: recipientKey,
        srcChain,
        srcAccount,
        destAccount,
        token: tokenA,
        amount,
        nonce: String(nonce),
      })
      console.log(`[test] WithdrawSubmit tx: ${wsTxHash}`)
    } else {
      console.warn('[test] No tokenA address, skipping withdrawSubmit')
      return
    }

    // 5. Compute withdraw hash and poll for operator approval
    const xchainHashId = computeXchainHashIdViaCast({
      srcChain,
      destChain: '0x00000001', // Anvil V2 chain ID
      srcAccount,
      destAccount,
      token: tokenA,
      amount,
      nonce: String(nonce),
    })
    console.log(`[test] Xchain hash id: ${xchainHashId}`)
    console.log('[test] Polling for operator approval...')
    const approved = await pollForApproval(ANVIL_RPC, bridgeAddress, xchainHashId, 60_000)
    console.log(`[test] Approval status: ${approved}`)

    // 6. Skip cancel window on anvil
    console.log('[test] Skipping cancel window...')
    await skipAnvilTime(ANVIL_RPC, 600) // Skip 10 minutes

    // 7. Execute withdrawal on anvil (release tokens to recipient)
    console.log('[test] Calling withdrawExecute on anvil...')
    const execTxHash = withdrawExecuteViaCast({
      rpcUrl: ANVIL_RPC,
      bridgeAddress,
      privateKey: recipientKey,
      xchainHashId,
    })
    console.log(`[test] WithdrawExecute tx: ${execTxHash}`)

    // 8. Check balance - recipient should have received tokenA tokens
    if (tokenA) {
      const finalBalance = await getErc20Balance(ANVIL_RPC, tokenA, recipient)
      console.log(`[test] Final balance: ${finalBalance} (was ${initialBalance})`)
      expect(finalBalance).toBeGreaterThan(initialBalance)
    }
  }, 90_000) // 90s timeout for this test
})
