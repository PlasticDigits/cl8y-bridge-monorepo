/**
 * EVM → EVM Bridge Integration Test
 *
 * Tests the full bridge transfer lifecycle from EVM (anvil) to EVM (anvil1):
 * 1. Record initial ERC20 balance on anvil1
 * 2. Deposit on anvil via cast
 * 3. Call withdrawSubmit on anvil1 bridge via cast
 * 4. Wait for operator approval
 * 5. Skip cancel window on anvil1
 * 6. Call withdrawExecute on anvil1 bridge via cast
 * 7. Assert recipient balance increased on anvil1
 *
 * ┌─────────────────────────────────────────────────────────────────────┐
 * │  REQUIRES FULL LOCAL INFRASTRUCTURE RUNNING BEFORE EXECUTION.      │
 * │                                                                    │
 * │  You need ALL of the following:                                    │
 * │    1. Anvil        (EVM devnet)       → localhost:8545             │
 * │    2. Anvil1       (second EVM chain) → localhost:8546             │
 * │    3. LocalTerra   (Cosmos devnet)    → localhost:1317 (LCD)       │
 * │    4. PostgreSQL   (operator DB)      → localhost:5433             │
 * │    5. Operator     (cl8y-relayer)     → localhost:9092             │
 * │    6. .env.e2e.local generated by the setup script                 │
 * │                                                                    │
 * │  Quick start:                                                      │
 * │    make test-bridge-integration                                    │
 * │                                                                    │
 * │  Or manually:                                                      │
 * │    docker compose up -d anvil anvil1 localterra postgres           │
 * │    npx vitest run --config vitest.config.integration.ts            │
 * │                                                                    │
 * │  DO NOT run via `npx vitest run` — use the integration config.     │
 * └─────────────────────────────────────────────────────────────────────┘
 */

import { describe, it, expect, beforeAll } from 'vitest'
import { readFileSync, existsSync } from 'fs'
import { resolve } from 'path'
import { getErc20Balance, skipAnvilTime } from '../../../e2e/fixtures/chain-helpers'
import {
  depositErc20ViaCast,
  getDepositNonceFromReceipt,
  withdrawSubmitViaCast,
  withdrawExecuteViaCast,
  pollForApproval,
  computeWithdrawHashViaCast,
  mintTestTokens,
  ANVIL_ACCOUNTS,
} from '../../../e2e/fixtures/transfer-helpers'

const ROOT_DIR = resolve(__dirname, '../../../../..')
const ENV_FILE = resolve(ROOT_DIR, '.env.e2e.local')

let envVars: Record<string, string> = {}
const ANVIL_RPC = 'http://localhost:8545'
const ANVIL1_RPC = 'http://localhost:8546'

function loadEnv() {
  if (!existsSync(ENV_FILE)) {
    throw new Error(
      '\n' +
      '╔══════════════════════════════════════════════════════════════════╗\n' +
      '║  BRIDGE TEST ABORTED — .env.e2e.local not found                ║\n' +
      '╠══════════════════════════════════════════════════════════════════╣\n' +
      '║  This file is generated by the E2E setup script after          ║\n' +
      '║  deploying contracts to local chains.                          ║\n' +
      '║                                                                ║\n' +
      '║  Quick start:  make test-bridge-integration                    ║\n' +
      '║  Or manually:  docker compose up -d anvil anvil1 localterra    ║\n' +
      '║  Then run:     npx vitest run --config vitest.config.integration.ts ║\n' +
      '╚══════════════════════════════════════════════════════════════════╝\n'
    )
  }
  const content = readFileSync(ENV_FILE, 'utf8')
  for (const line of content.split('\n')) {
    const trimmed = line.trim()
    if (!trimmed || trimmed.startsWith('#')) continue
    const eq = trimmed.indexOf('=')
    if (eq > 0) {
      envVars[trimmed.slice(0, eq)] = trimmed.slice(eq + 1)
    }
  }
}

describe('EVM → EVM Bridge Transfer (anvil → anvil1)', () => {
  let bridgeAddress: string  // anvil bridge
  let bridge1Address: string // anvil1 bridge
  let lockUnlockAddress: string // anvil lockUnlock handler
  let lockUnlock1Address: string // anvil1 lockUnlock handler
  let tokenA: string         // on anvil
  let token1A: string        // corresponding token on anvil1

  beforeAll(() => {
    loadEnv()
    bridgeAddress = envVars['VITE_EVM_BRIDGE_ADDRESS'] || ''
    bridge1Address = envVars['VITE_EVM1_BRIDGE_ADDRESS'] || ''
    lockUnlockAddress = envVars['EVM_LOCK_UNLOCK_ADDRESS'] || ''
    lockUnlock1Address = envVars['EVM1_LOCK_UNLOCK_ADDRESS'] || ''
    tokenA = envVars['ANVIL_TOKEN_A'] || ''
    token1A = envVars['ANVIL1_TOKEN_A'] || ''

    if (!bridgeAddress || !bridge1Address) {
      throw new Error('Missing bridge addresses in .env.e2e.local')
    }

    // Pre-fund the LockUnlock handler on anvil1 with tokens
    // In a real bridge setup, other deposits would fund it. For tests, we mint directly.
    if (token1A && lockUnlock1Address) {
      try {
        mintTestTokens({
          rpcUrl: ANVIL1_RPC,
          tokenAddress: token1A,
          toAddress: lockUnlock1Address,
          amount: '10000000000000000000', // 10 tokens
          minterKey: ANVIL_ACCOUNTS.deployerKey,
        })
        console.log(`[setup] Pre-funded LockUnlock on anvil1 with tokens`)
      } catch (err) {
        console.warn('[setup] Failed to pre-fund LockUnlock:', err)
      }
    }
  })

  it('should complete an EVM → EVM transfer with operator relay', async () => {
    const depositor = ANVIL_ACCOUNTS.user1
    const depositorKey = ANVIL_ACCOUNTS.user1Key
    const recipient = ANVIL_ACCOUNTS.user2
    const recipientKey = ANVIL_ACCOUNTS.user2Key
    const amount = '1000000000000000000' // 1 token (18 decimals)

    if (!tokenA || !token1A) {
      console.warn('[test] Token addresses not available, skipping test')
      return
    }

    // 1. Record initial ERC20 balance on anvil1
    const initialBalance = await getErc20Balance(ANVIL1_RPC, token1A, recipient)
    console.log(`[test] Initial balance on anvil1: ${initialBalance}`)

    // 2. Mint tokens to depositor on anvil and deposit
    try {
      mintTestTokens({
        rpcUrl: ANVIL_RPC,
        tokenAddress: tokenA,
        toAddress: depositor,
        amount,
        minterKey: ANVIL_ACCOUNTS.deployerKey,
      })
      console.log(`[test] Minted ${amount} tokens to ${depositor} on anvil`)
    } catch (err) {
      console.warn('[test] Mint failed (may already have tokens):', err)
    }

    // Deposit on anvil → dest chain = anvil1
    // V2 chain ID: Anvil1 is registered as 0x00000003 on Anvil's ChainRegistry
    const destChain = '0x00000003'
    const destAccount = '0x' + recipient.slice(2).padStart(64, '0')

    const { txHash } = depositErc20ViaCast({
      rpcUrl: ANVIL_RPC,
      bridgeAddress,
      lockUnlockAddress: lockUnlockAddress || undefined,
      privateKey: depositorKey,
      tokenAddress: tokenA,
      amount,
      destChain,
      destAccount,
    })
    console.log(`[test] Deposit tx on anvil: ${txHash}`)

    // Extract nonce
    const nonce = getDepositNonceFromReceipt(ANVIL_RPC, txHash)
    console.log(`[test] Deposit nonce: ${nonce}`)

    // 3. Call withdrawSubmit on anvil1 bridge
    // V2 chain ID: Anvil = 0x00000001 globally
    const srcChain = '0x00000001'
    const srcAccount = '0x' + depositor.slice(2).padStart(64, '0')

    const wsTxHash = withdrawSubmitViaCast({
      rpcUrl: ANVIL1_RPC,
      bridgeAddress: bridge1Address,
      privateKey: recipientKey,
      srcChain,
      srcAccount,
      destAccount,
      token: token1A,
      amount,
      nonce: String(nonce),
      srcDecimals: 18,
    })
    console.log(`[test] WithdrawSubmit tx on anvil1: ${wsTxHash}`)

    // Compute withdraw hash for polling
    const withdrawHash = computeWithdrawHashViaCast({
      srcChain,
      destChain: '0x00000003',
      srcAccount,
      destAccount,
      token: token1A,
      amount,
      nonce: String(nonce),
    })
    console.log(`[test] Withdraw hash: ${withdrawHash}`)

    // 4. Poll for approval
    console.log('[test] Polling for operator approval...')
    const approved = await pollForApproval(ANVIL1_RPC, bridge1Address, withdrawHash, 60_000)
    console.log(`[test] Approval status: ${approved}`)

    // 5. Skip cancel window on anvil1
    console.log('[test] Skipping cancel window on anvil1...')
    await skipAnvilTime(ANVIL1_RPC, 600) // Skip 10 minutes

    // 6. Execute withdrawal on anvil1 bridge (release tokens to recipient)
    console.log('[test] Calling withdrawExecute on anvil1...')
    const execTxHash = withdrawExecuteViaCast({
      rpcUrl: ANVIL1_RPC,
      bridgeAddress: bridge1Address,
      privateKey: recipientKey,
      withdrawHash,
    })
    console.log(`[test] WithdrawExecute tx on anvil1: ${execTxHash}`)

    // 7. Check balance on anvil1
    const finalBalance = await getErc20Balance(ANVIL1_RPC, token1A, recipient)
    console.log(`[test] Final balance on anvil1: ${finalBalance} (was ${initialBalance})`)

    // Assert balance increased (accounting for bridge fees)
    expect(finalBalance).toBeGreaterThan(initialBalance)
  }, 120_000) // 2 min timeout
})
